-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

-- DROP TABLE IF EXISTS graphql._type CASCADE;

-- DROP TABLE IF EXISTS graphql._field CASCADE;

CREATE TABLE IF NOT EXISTS public.categories
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    title text COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_title_key UNIQUE (title)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.categories
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.categories TO anon;

GRANT ALL ON TABLE public.categories TO postgres;

GRANT ALL ON TABLE public.categories TO supabase_admin;

GRANT ALL ON TABLE public.categories TO authenticated;

GRANT ALL ON TABLE public.categories TO service_role;

CREATE TABLE IF NOT EXISTS public.product
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title text COLLATE pg_catalog."default" NOT NULL,
    price bigint NOT NULL,
    image text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default" NOT NULL,
    published boolean NOT NULL DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text),
    category bigint,
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT product_category_fkey FOREIGN KEY (category)
        REFERENCES public.categories (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_created_by_fkey FOREIGN KEY (created_by)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.product
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.product TO anon;

GRANT ALL ON TABLE public.product TO postgres;

GRANT ALL ON TABLE public.product TO supabase_admin;

GRANT ALL ON TABLE public.product TO authenticated;

GRANT ALL ON TABLE public.product TO service_role;
CREATE POLICY "Enable update for users based on user_id"
    ON public.product
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = created_by));



CREATE TABLE IF NOT EXISTS public.profile
(
    created_at timestamp with time zone DEFAULT now(),
    first_name text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default" NOT NULL,
    last_name text COLLATE pg_catalog."default",
    phone_number text COLLATE pg_catalog."default",
    city text COLLATE pg_catalog."default",
    state text COLLATE pg_catalog."default",
    country text COLLATE pg_catalog."default",
    photo_url text COLLATE pg_catalog."default",
    user_id uuid NOT NULL,
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    CONSTRAINT profile_pkey PRIMARY KEY (id),
    CONSTRAINT profile_user_id_key UNIQUE (user_id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT profile_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profile
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.profile
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profile TO anon;

GRANT ALL ON TABLE public.profile TO postgres;

GRANT ALL ON TABLE public.profile TO supabase_admin;

GRANT ALL ON TABLE public.profile TO authenticated;

GRANT ALL ON TABLE public.profile TO service_role;
CREATE POLICY "Enable delete for users based on user_id"
    ON public.profile
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable read access to all users"
    ON public.profile
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'anon'::text));
CREATE POLICY "Enable update for users based on user_id"
    ON public.profile
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Insert for auth users only"
    ON public.profile
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$

begin
  insert into public.profile (user_id, email)
  values (new.id, new.email);
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

CREATE OR REPLACE FUNCTION public.pgrst_watch()
    RETURNS event_trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$

BEGIN
  NOTIFY pgrst, 'reload schema';
END;
$BODY$;

ALTER FUNCTION public.pgrst_watch()
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO anon;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO postgres;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO authenticated;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO service_role;

GRANT EXECUTE ON FUNCTION public.pgrst_watch() TO PUBLIC;
